JavaScript5的的巩固
值类型与引用类型
值类型复制
引用类型复制
值类型和引用类型传递
arguments
函数的leangth属性
参数对像化分装
值类型： String  Number  Boolean     放在栈内存里面 -->量对象
引用行：Arrary   Object     Function  放在堆内存里面
引用类型的存储的位置是在堆内存里面，但是在栈里面是存有一个地址，对应堆里面的内容。


函数参数
    形参：函数定义的参数
    实参：函数调用的实际传递的参数
    参数匹配是从左向右匹配。如果实参的个数小于形参，后面的参数对应的赋值是undefined
    实参的个数大于形参的个数，可以通过arguments 访问
    如果函数的参数多于4个，那么开发人员很难记忆，最好将参数分装成对象来接受，队形的属性是无序的，可以方便开发人员使用
    函数参数的值传递和引用传递
        引用传递的参数，是传递引用对象的地址，函数内部修改会影响传递餐厨的引用对象
        值传递是一个值类型的副本，函数内部不影响函数外部的参数变量；

函数的搞基内幕
    JavaScript 事件循环机制: Event loop
        队列的数据结构： 先进先出；
        浏览器分为：
            JavaScript执行线程：负责执行代码 
            UI线程：负责UI展示，负责展示给用户看
            JavaScript事件循环线程
       JavaScript是单线程的， 为什么是单线程的？
            JavaScript执行线程和UI线程是互斥的
            JavaScript中的代码都是排队执行，不会同步执行多个任务；
            JavaScript中的任务分为同步任务和异步任务
                同步任务：一般赋值操作，循环，分支语句等都是同步任务 -->js基础部分都是同步任务
                异步任务：DOM事件、ajax、BOM的一些 API
        如果是同步任务直接在主线程中执行；
        如果任务是异步任务，那么运行的到异步任务时，异步任务就会退出主线程，主线程进行下一个任务的获取处理
        如果异步任务完成，就会插入到任务对列的尾部，等待主线程处理
总结：JavaScript代码是以对列的形式一个一个执行的，同一时间只能执行一个；



    变量的作用域
    变量提升与函数的提升
    作用域链
    函数的arguments
    函数的执行期上下文
    构造函数内部直行过程
    函数的四种调用模式
    没有重载
    函数的属性和方法


函数的执行期上下文的概念
    栈的数据结构：
        先进后出；
        栈顶进行压入数据 push（）
        栈顶弹出数据 pop（）


    EC：函数执行环境（或者执行期上下文）Execution Context
        
    ECS：执行环境栈 Execution Context Stack
        #JavaScript执行在单线程上，所有的代码都是排队执行
        #一开始浏览器执行全局的代码时，首先创建全局的执行期上下文，压入执行栈的顶部；
        #每当进入一个函数的执行就会创建函数的执行期上下文，并且把它压入执行栈的顶部，
        #当前函数执行完成后，当前函数的执行期上下文出栈，并等待垃圾收回
        #浏览器的Js执行引擎中还是访问栈顶的执行上下文
        #全局上下文只有唯一的一个，她在浏览器关闭时出栈

    VO变量对象（variable object）是说JS的执行期上下文中都有个对象用来存放执行期上下文中可被访问但是不是不能被delete的函数标示符，形参，变量声明等

    他们会被挂在一个对象上，队象的属性对应他们的名字，对象属性的值对应他们的值，但是这个对象是规范上的或者说是引擎实现上的，不可以在js换机中访问到活动对象
            
    AO激活对象：（Activation object）有了变量对象存个上下文中的东西，但是他什么时候能被访问到？就是每进入一个执行上下文时，这个执行上下文的变量对象被激活，也就是该上

    下文中的函数标示符，形参变量 变量声明等就可以被访问到了

    执行期上下文的生命周期
    总的生命周期：创建——>执行——>出栈等待销毁
    创建阶段：
        #创建作用域链（Scope Chain）
        #创建变量对象（或者Ao）：首先初始化函数的参数arguments，初始化函数声明，初始化变量（undefined），函数的优先级要高于变量，如果变量和函数重名。变量会被忽略；
            ￥创建arguments对象，检查上下文，初始化参数名称和值并创建引用的复制。
            ￥扫描上下文的函数声明（而非函数表达式）；
                @为发现的每一个函数，下变量对象创建一个属性———确切的说是函数的名字——其中有一个指向函数在内存中的引用；
                @如果函数的名字已经存在，引用指针将会被重写
            ￥扫描上下文的变量声明；
                @为发现的每一个变量声明，下变量对象创建一个属性———确切的说是变量的名字——并将变量的值初始化为undefined
                @如果变量的名字已经存在，将不会进行任何的操作并继续扫描
            ￥求出上下文内部“this”的指向；
    执行阶段：
        执行变量的肤质，代码执行
    回收阶段：
        执行后上下文出栈，等虚拟机收回执行上下文； 

函数变量作用域
    作用域：就是变量声明的区域，就会说变量和函数的可访问范围。在全局声明的变量为全局可见可访问的就是全局变量，如果在函数内部声明的变量就只能在函数内部访问就是局部变量、
    函数的参数只能在函数内部访问，就是局部变量
    JavaScript没有块级的作用域，只有函数作用域和全局作用域，for循环内部定义的变量是函数级别的作用域
    变量没有在函数内声明或者声明的时候没有带 var 就是全局变量,拥有全局作用域，特殊： var a=b=c=0; b和c 是全局变量
    全局作用域的变量可以在js中的任何地方调用，函数作用域的变量只能在函数自己内部中调用，包括自己内部定义的其他函数都可以直接调用
    变量的作用域是以它声明时为准，因为变量的作用域在JS代码解释阶段就已经完成规则的定制


没有块级作用域
    for循环 、while 循环中定义的变量的作用域是函数级别的作用域。
    C C# C++ Java ：for循环中定义的变量，只能在for循环内部访问，但是在js中，因为没有块级作用域，所以在for循环内部定义的变量
    在整个所在的函数内部是可以访问的

变量提升（hositing）
    如果一个声明的变量在函数的内部，那么他的作用域就是函数的背部。如果在全局的环境下声明，
    那么他的作用域就是全局的。通过var声明的变量是无法用 delete删除的。
    函数内部的声明变量会被提升到函数的头部，函数在解析执行的时候，先进行变量声明的处理，然后
    在运行函数的代码
    变量和赋值语句一起书写，在js引擎解析时，会将其拆成声明和赋值两个部分，声明置顶，赋值保留
    在原来的位置
    变量重复声明不会出错，后面写的会覆盖前面写的

作用域链
    作用域链是一个数组
    作用域链是控制变量作用域的有序访问的js内部实现
    作用域链存储在函数的执行期上下文中，作用域中存放的执行环境中的 VO或者AO。
    当前函数的作用域对象都是在最前端，而且全局的在最末端
    变量（标示符）的搜索都是从作用域链的最前端向后搜索，直到全局作用域，标示符的解析时沿着作用域链一级一级搜索的过程
    从第一对开始。主机向后回溯，直到找到同名的标示符为止，找到后不再继续遍历，找不到就报错

函数的四种调用模式与this
    方法调用模式
        如果一个函数作为一个方法属性调用，那么他的调用模式就是方法调用
        var a = {}, a.toString()//方法调用
        方法调用模式的this指向调用对象
    
    函数调用模式
        如果一个函数被直接调用，那么调用者其实就是全局对象 ： window  、、 如果是严格模式下 是undefined
        函数调用模式 this 指向全局
        function f1(){}; f1();//函数调用模式
    
    构造器调用模式
        构造器调用模式就是构造函数调用
        构造器模式调用必须有关键字New的存在
        构造器模式调用的this指向创造出来的新对象
        var t =new Dog(); //构造器调用模式
        构造函数乐意返回一个值，但是如果是简单类型就会被忽略，如果是引用类型会替换新创建的对象返回
    
    apply /call 调用模式（借用方法的模式）
        apply和call可以改变函数调用的内部this的指向
        apply和call的功能是一样的，只不过参数不一样，第一参数都是改变函数内部的this的指向。
        call的第二参数开始后面的都是传给函数的参数，可是是多个，用逗号分开
        apply 第二参数是一个传给函数的数组；
        调用：function f(a){} f.call(window,2); m.apply(window ,[2])

Js中函数没有重载
    js中函数不能重名，如果重名后面的会把前面的覆盖
    原因：所有的函数声明都会创建一个VO或者一个AO上的一个属性。而后面声明的函数会把前面的Vo和Ao中的同名属性覆盖 
    重载的概念：在程序中可以定义相同的名字，不同参数的形式的不同函数，函数在调用的时候，自动识别不同参数对应的函数
    实现了相同函数不同的函数调用
    js中通过arguments实现函数的重载
    数组的slice方法，splice方法等都可以传递一个参数或是多个参数，不同的参数方法内部实现的不一样，就是方法重载

函数的递归调用
    函数的递归调用就是指:函数调用自身；(需要有边界条件)
    arguments.callee就是指函数自身的变量，所以可以直接用它来代替函数名，在匿名函数中非常有用，但是在在严格模式下会报错
    函数表达式方式定义的时候，还可以用命名函数表达式；
        var f = function s(){} 在s函数内部 ，可以直接使用s变量。
    案例：
        求1到100的和，请使用递归。
        求num的阶乘，用递归实现。
        求f(n)的斐波那契数列值。 f(n)=f(n-1)+f(n-2) n>=3;


函数式编程
    函数式JavaScript的一等公民
    所谓的“一等公民”（first class）,指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另
    一个函数，或者作为别的函数的返回值。
    数组的sort方法回顾；
    数组的map方法（IE9+ 支持）
        放回：undefined
        forEach方法按升序为数组中的有效值得每一项执行一次callback函数，那些已删除（使用delete方法等情况）或者未初始化的项将被跳过
        （但是不包括那些值为undefined的项）（例如稀疏数组）
        回调函数的参数
            数组当前的值
            数组当前的项的索引
            数组对象本身

函数的属性和方法；
    f  instanceof Object ; // ture
    语法：object instanceof constructor
    参数： 
        object :要检测的对象； 
        constructor:某个构造函数
        instanceof 运算符用来检测 constructor.prototype 是否存在于参数object的原型链上；
    函数的内属性： arguments 可以在函数内部使用
    函数的自身属性：leagth ，函数定义的形参的个数。
    另外我可以自定义函数的其他属性和方法。【一般用于全局变量、静态变量、公共存储】


原型链
    函数的原型对象（prototype）
    原型对象的构造函数（constructor）
    内部原型（_proto_）
        javascript 是基于原型的面向对象语言，也就是说多有的对象都是基于原型上进行创建的，而不像Java和c#等是基于一个类型的模板创建的
        函数都有prototype属性指向函数的原型对象【只有函数根除外】
        所有的对象都有_proto_属性（非标准属性，但是所有的浏览器都实现了【null除外】）
        Object是构造函数，也是对象。Object的prototype是所对象的根
        Function是函数对象的构造函数，Function的原型对象是所有函数的根，而他的内部原型是Object的原型对象，这就是关键点了;   Function.prototype 是所有函数的根
        构造函数都有prototype 属性，称之为构造函数的原型
        通过构造函数创建出来的对象都会有继承构造函数原型上的方法和属性
        原型对象上都有constructor属性，指向对应得构造函数；

闭包
    函数的作用域：函数的作用域与全局的作用域
    没有块级作用域
    闭包的使用
    沙箱模式
    闭包：（英语：Closure）使引用了自由变量的函数。这个被引用的自由变量和这个函数一同存在，即使已经离开了创建他的环境也不例外，所以
    有另一种书法认为闭包是由函数和与其相关的引用环境组合而形成的实体
    闭包是一个函数和函数声明的词法环境的结合
    结论：JavaScript中任何一个函数都是闭包。
    特殊情况：由于函数嵌套调用的时候，如果内部函数访问外部函数的变量，可能导致闭包的出现；

闭包的应用
    匿名自执行函数模拟块级作用域
    (function(){
        //块级作用域
    })();
    循环注册dom事件中的index

    setTimeOut中的闭包的应用
    for（var  i= 0; i<10;i++）{
         setTimeOut(function(){
             console.log(i);
         })
    }

闭包的缺点
    闭包会导致JavaScript执行效率下降（目前v8引擎已经对闭包做了很多的性能优化，基本不用考虑）
    闭包会导致内存会驻留，如果是大量对象的闭包环境注意内存消耗；

面向对象
    面向对象的概念；
        面向对象就是一种思考问题的和组织代码的方式；
        把任何的数据和行为抽象成一个形象的对象，类似人生活中思考的方式，就是面向对象；
        继承： 类似的对象进行公共的抽象，并公共复用的继承；
    对象的创建；
    面向对象的继承；

构造函数创建对象；
    优点：
        所创建出来的对象，艘可以找到他的原型和构造函数
        公共的属性和方法也是可以在创建的时候统一创建和维护；

    缺点：
        对象的函数，每个对象都会拥有一份内存拷贝，浪费内存；

原型构建对象
    优点：
        所有原型上的属性和方法在所有的新对象中可以进行共享
    缺点：
        如果对象需要自己特有的属性值，不予其他对象共享，则必须跟构造函数模式进行配合；

组合构造函数模式与原型模式构建对象
    组合使用构造函数模式与原型模式
    公告属性和方法放到原型上，独有的属性使用构造函数模式，放到对象自己身上。
    优点：既保证了方法等共享属性能只在内存中保存一份，节省内存又可以实现每个对象有自己单独存放的属性
    是一种经典的构建对象的方法

对象的继承
    原型继承的方式
    借用构造函数继承、
    组合继承
    原型方法继承
    寄生继承方式
    终极方式：寄生组合打的方式

原型式继承
    原型式继承是为了避免调用父类构造函数的一种巧妙的方式。本质就是借用对象来邹傲另外一个对象
    缺点：原型对象上的引用属性会造成子类对象的共享；
寄生组合模式
    由于组合继承模式需要执行两次的父类的构造函数，使用寄生继承模式替代原型继承模式，那么就可以
    实现父类的构造函数只执行一次的效果，是目前认为最金典的继承模式，最好的继承模式

私有变量
    JavaScript 中并没有私有变量的概念，但是我们可以通过默写方式进行模拟。所谓的私有变量就是指：
    对象的某个属性只能通过对象的方法进行访问，不能直接通过对象进行访问
    构造函数模拟私有变量的方式
    其他模拟的方法